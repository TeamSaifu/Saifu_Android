name: BacklogとPull Requestの同期
on:
  pull_request:
    types:
      - opened
      - edited
      - closed
env:
  SPACE_KEY: "ecccomp"
  PROJECT_KEY: "IE3A_2020_ZENKI_E"
  LABEL_NAME: "Backlog連携"
  IN_REVIEW_STATUS_ID: 3
  CLOSED_STATUS_ID: 4
  BACKLOG_API_KEY: ${{ secrets.BACKLOG_API_KEY }}

jobs:
  notice:
    name: 参照されたことをコメント
    runs-on: ubuntu-latest
    if: |
      !github.event.pull_request.merged && (github.event.action == 'opened' || github.event.action == 'edited')
    steps:
      - uses: actions/github-script@0.4.0
        with:
          github-token: ${{ github.token }}
          script: |
            const https = require('https');
            const querystring = require('querystring');
            // Promiseでhttps.requestを呼ぶメソッド
            const request = (url, payload, options = {}) => new Promise((resolve, reject) => {
              const { method = 'GET' } = options;
              console.log(`[request] ${method}: ${url}`);
              const req = https.request(url, options, (res) => {
                res.setEncoding('utf8');
                res.on('data', resolve);
              });
              if (payload) {
                req.write(querystring.stringify(payload));
              }
              req.on('error', reject);
              req.end();
            });
            (async () => {
              const { SPACE_KEY, PROJECT_KEY, IN_REVIEW_STATUS_ID, BACKLOG_API_KEY } = process.env;
              const { html_url, body, number, title } = context.payload.pull_request;
              const { full_name, name: repoName, owner } = context.payload.repository;
              const { login: ownerName } = owner;
              const backlogDomain = `https://${SPACE_KEY}.backlog.com`;
              const apiEndpoint = `${backlogDomain}/api/v2`;
              // コメントされた課題
              const commentedIssues = body
                .split(/\n/)
                .map((line) => {
                  const re = new RegExp(`\\* *(?:fixes|refs) *(${PROJECT_KEY}-\\d+)`);
                  return line.match(re);
                })
                .filter(Boolean)
                .map((matches) => matches[1]);
              // コメント一覧を取得
              const comments = await github.issues.listComments({
                owner: ownerName,
                repo: repoName,
                issue_number: number,
              });
              // リファレンスしたコメントを取得
              const referencedIssues = comments.data
                .filter((data) => data.user.type === 'Bot' && data.body.startsWith('次の課題にリファレンスしました：'))
                .flatMap((data) => data.body.match(/\[([^\[\]]+)\]\([^()]+\)/g))
                .map((link) => link.replace(/\[([^\[\]]+)\].*/, '$1'));
              // リファレンスされていない課題
              const unreferencedIssues = commentedIssues.filter((id) => !referencedIssues.includes(id));
              const uniqUnreferencedIssues = [ ...new Set(unreferencedIssues) ];
              // リファレンスすべき課題がなければ終了
              if (uniqUnreferencedIssues.length === 0) {
                return;
              }
              await Promise.all([
                // リファレンスされていない課題を「レビュー中」に変更
                ...uniqUnreferencedIssues.map((id) => (
                  request(`${apiEndpoint}/issues/${id}?apiKey=${BACKLOG_API_KEY}`, {
                    statusId: IN_REVIEW_STATUS_ID,
                    comment: `次のPull Requestからリファレンスされました： [${full_name}#${number} ${title}](${html_url})`,
                  }, {
                    method: 'PATCH',
                    headers: {
                      'Content-Type': 'application/x-www-form-urlencoded',
                    },
                  })
                )),
              ]);
              const referencedIssueLinks = uniqUnreferencedIssues
                .map((id) => `[${id}](${backlogDomain}/view/${id})`)
                .join('、');
              github.issues.createComment({
                issue_number: number,
                owner: ownerName,
                repo: repoName,
                body: `次の課題にリファレンスしました： ${referencedIssueLinks}`,
              });
            })();
  label:
    name: ラベルの有無をチェック
    runs-on: ubuntu-latest
    if: |
      !github.event.pull_request.merged && (github.event.action == 'opened' || github.event.action == 'edited')
    steps:
      - uses: actions/github-script@0.4.0
        with:
          github-token: ${{ github.token }}
          script: |
            const { number, body, labels } = context.payload.pull_request;
            const { full_name, name: repoName, owner } = context.payload.repository;
            const { login: ownerName } = owner;
            const { LABEL_NAME, PROJECT_KEY, BACKLOG_API_KEY } = process.env;
            // 設定するラベルがすでに設定されているか
            const hasLabel = labels.some((label) => label.name === LABEL_NAME);
            // 説明文内に課題が参照されているか
            const re = new RegExp(`\\* *(?:fixes|refs) *(${PROJECT_KEY}-\\d+)`);
            const hasIssueInDescription = re.test(body);
            // ラベルが設定されておらず、課題が参照されている場合はラベルを追加
            if (!hasLabel && hasIssueInDescription) {
              github.issues.addLabels({
                issue_number: number,
                owner: ownerName,
                repo: repoName,
                labels: [LABEL_NAME],
              });
              return;
            }
            // ラベルが設定されているが、課題が参照されていない場合はラベルを削除
            if (hasLabel && !hasIssueInDescription) {
              github.issues.removeLabel({
                issue_number: number,
                owner: ownerName,
                repo: repoName,
                name: LABEL_NAME,
              });
              return;
            }
  close:
    name: 課題のクローズ
    runs-on: ubuntu-latest
    if: |
      github.event.action == 'closed' && github.event.pull_request.merged
    steps:
      - uses: actions/github-script@0.4.0
        with:
          github-token: ${{ github.token }}
          script: |
            const https = require('https');
            const querystring = require('querystring');
            // Promiseでhttps.requestを呼ぶメソッド
            const request = (url, payload, options = {}) => new Promise((resolve, reject) => {
              const { method = 'GET' } = options;
              console.log(`[request] ${method}: ${url}`);
              const req = https.request(url, options, (res) => {
                res.setEncoding('utf8');
                res.on('data', resolve);
              });
              if (payload) {
                req.write(querystring.stringify(payload));
              }
              req.on('error', reject);
              req.end();
            });
            (async () => {
              const { SPACE_KEY, PROJECT_KEY, CLOSED_STATUS_ID, BACKLOG_API_KEY } = process.env;
              const { html_url, body, number, title } = context.payload.pull_request;
              const { full_name, name: repoName, owner } = context.payload.repository;
              const { login: ownerName } = owner;
              const backlogDomain = `https://${SPACE_KEY}.backlog.com`;
              const apiEndpoint = `${backlogDomain}/api/v2`;
              // クローズする課題
              const closableIssues = body
                .split(/\n/)
                .map((line) => {
                  const re = new RegExp(`\\* *fixes *(${PROJECT_KEY}-\\d+)`);
                  return line.match(re);
                })
                .filter(Boolean)
                .map((matches) => matches[1]);
              const uniqClosableIssues = [ ...new Set(closableIssues) ];
              // リファレンスされたIssueがなければ終了
              if (uniqClosableIssues.length === 0) {
                return;
              }
              await Promise.all([
                // 課題のステータスを「完了」に変更
                ...uniqClosableIssues.map((id) => (
                  request(`${apiEndpoint}/issues/${id}?apiKey=${BACKLOG_API_KEY}`, {
                    statusId: CLOSED_STATUS_ID,
                    resolutionId: 0,
                    comment: `リファレンスされていたPull Requestがマージされました： [${full_name}#${number} ${title}](${html_url})`,
                  }, {
                    method: 'PATCH',
                    headers: {
                      'Content-Type': 'application/x-www-form-urlencoded',
                    },
                  })
                )),
              ]);
              const closedIssueLinks = uniqClosableIssues
                .map((id) => `[${id}](${backlogDomain}/view/${id})`)
                .join('、');
              github.issues.createComment({
                issue_number: number,
                owner: ownerName,
                repo: repoName,
                body: `次の課題のステータスを完了にしました： ${closedIssueLinks}`,
              });
            })();
